import random
from openai_generate import OpenAI, AzureOpenAI
from utils import *
from prompt_functions import *
import os


class EvolInstruct:
    def __init__(self, num_iterations, initial_dataset, evol_model="gpt-4", eliminator_model="gpt-35-turbo",
                 azure_config_path=None, use_requests=True, verbose=False):

        self.num_iterations = num_iterations
        self.dataset = initial_dataset
        self.verbose = verbose
        if azure_config_path:
            config = load_config(azure_config_path)
            self.evol_model = AzureOpenAI(config, evol_model, use_requests=use_requests)
            self.eliminator_model = AzureOpenAI(config, eliminator_model,
                                                use_requests=use_requests) if eliminator_model else None
        else:
            openai_api_key = os.environ.get("OPENAI_API_KEY")
            self.evol_model = OpenAI(openai_api_key, evol_model, use_requests=use_requests)
            self.eliminator_model = OpenAI(eliminator_model, use_requests=use_requests) if eliminator_model else None

        self.evol_model_kwargs = {"temperature": 1, "max_tokens": 2048, "top_p": 0.95, "frequency_penalty": 0,
                                  "presence_penalty": 0, "stop": None}

        self.breadth_functions = {
            "Breadth": createBreadthPrompt,
        }
        self.depth_functions = {
            "Constraints": createConstraintsPrompt,
            "Deepen": createDeepenPrompt,
            "Concretizing": createConcretizingPrompt,
            "Reasoning": createReasoningPrompt,
        }
        self.evol_functions = self.breadth_functions | self.depth_functions

        self.eliminator_functions = {
            "Comparison": createComparisonEliminatorPrompt,
        }

    def select_prompt(self, instruction, function_names):
        # Select a prompt for in-depth or in-breadth evolution randomly
        function = self.evol_functions[random.choice(function_names)]
        return function(instruction)

    def instruction_evolver(self, instruction, function_names=None):
        if function_names is None:
            function_names = list(self.evol_functions.keys())
        prompt = self.select_prompt(instruction, function_names)
        return self.evol_model.generate(prompt, **self.evol_model_kwargs)

    def instruction_eliminator(self, original_instruction, evolved_instruction, response):
        # Rule 1: The evolved instruction does not provide any information gain compared to the original one.
        if original_instruction == evolved_instruction:
            return False, "Equal"
        if self.eliminator_model:
            prompt = createComparisonEliminatorPrompt(original_instruction, evolved_instruction)
            comparison_response = self.eliminator_model.generate(prompt, **self.evol_model_kwargs)
            if "equal" in comparison_response.lower():
                return False, "Equal"

        # Rule 2: The evolved instruction makes it difficult for the LLM to generate a response.
        if 'sorry' in response.lower() and "sorry" not in original_instruction.lower() and len(response.split()) < 80:
            return False, "Sorry"

            # Rule 3: The response generated by the LLM only contains punctuation and stop words.
            # Not sure if I should use this rule

        # Rule 4: The evolved instruction obviously copies some words from the evolving prompt.
        if any(phrase in evolved_instruction.lower() for phrase in ['given prompt', 'rewritten prompt', 'new prompt']):
            return False, "Leak from Prompt"

        return True, "Success"

    def evolve(self):
        for _ in range(self.num_iterations):
            new_dataset = []
            for example in self.dataset:
                instruction, response = example["input"], example["output"]

                # Stage 1: Evolve instruction
                evolved_instruction = self.instruction_evolver(instruction)
                evolved_instruction = clean_instruction(evolved_instruction)

                # Stage 2: Generate response from evolved instruction
                evolved_response = self.evol_model.generate(evolved_instruction, **self.evol_model_kwargs)

                # Stage 3: Eliminator
                success, reason = self.instruction_eliminator(instruction, evolved_instruction, evolved_response)

                if success:
                    new_dataset.append(
                        {"evolved_instruction": evolved_instruction, "evolved_response": evolved_response,
                         "original_instruction": instruction, "original_response": response})
                else:
                    self.dataset.append(example)

                if self.verbose:
                    print(f"###Instruction\n: {instruction}")
                    print(f"##Response\n: {response}\n")
                    print(f"###Evolved Instruction\n: {evolved_instruction}")
                    print(f"##Evolved Response\n: {evolved_response}")
                    print(f"Success: {success}, Reason: {reason}")
                    print("=" * 50)

            self.dataset = new_dataset